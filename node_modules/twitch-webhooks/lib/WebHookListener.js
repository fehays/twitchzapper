"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var https = require("https");
var portFinder = require("portfinder");
var publicIp = require("public-ip");
var getRawBody = require("raw-body");
var twitch_1 = require("twitch");
var BanEventSubscription_1 = require("./Subscriptions/BanEventSubscription");
var ExtensionTransactionSubscription_1 = require("./Subscriptions/ExtensionTransactionSubscription");
var FollowsFromUserSubscription_1 = require("./Subscriptions/FollowsFromUserSubscription");
var FollowsToUserSubscription_1 = require("./Subscriptions/FollowsToUserSubscription");
var ModeratorEventSubscription_1 = require("./Subscriptions/ModeratorEventSubscription");
var StreamChangeSubscription_1 = require("./Subscriptions/StreamChangeSubscription");
var SubscriptionEventSubscription_1 = require("./Subscriptions/SubscriptionEventSubscription");
var UserChangeSubscription_1 = require("./Subscriptions/UserChangeSubscription");
// eslint-disable-next-line @typescript-eslint/no-require-imports
var polka = require("polka");
var WebHookListener = /** @class */ (function () {
    function WebHookListener(_config, 
    /** @private */ _twitchClient) {
        this._config = _config;
        this._twitchClient = _twitchClient;
        this._subscriptions = new Map();
    }
    WebHookListener.create = function (client, config) {
        if (config === void 0) { config = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var listenerPort, _a, reverseProxy, _b, _c, _d;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = config.port;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, portFinder.getPortPromise()];
                    case 1:
                        _a = (_e.sent());
                        _e.label = 2;
                    case 2:
                        listenerPort = _a;
                        reverseProxy = config.reverseProxy || {};
                        _b = WebHookListener.bind;
                        _c = {};
                        _d = config.hostName;
                        if (_d) return [3 /*break*/, 4];
                        return [4 /*yield*/, publicIp.v4()];
                    case 3:
                        _d = (_e.sent());
                        _e.label = 4;
                    case 4: return [2 /*return*/, new (_b.apply(WebHookListener, [void 0, (_c.hostName = _d,
                                _c.port = listenerPort,
                                _c.ssl = config.ssl,
                                _c.reverseProxy = {
                                    port: reverseProxy.port || listenerPort,
                                    ssl: reverseProxy.ssl === undefined ? !!config.ssl : reverseProxy.ssl,
                                    pathPrefix: reverseProxy.pathPrefix || ''
                                },
                                _c.hookValidity = config.hookValidity,
                                _c), client]))()];
                }
            });
        });
    };
    WebHookListener.prototype.listen = function () {
        var e_1, _a;
        var _this = this;
        if (this._server) {
            throw new Error('Trying to listen while already listening');
        }
        if (this._config.ssl) {
            var server = https.createServer({
                key: this._config.ssl.key,
                cert: this._config.ssl.cert
            });
            this._server = polka({ server: server });
        }
        else {
            this._server = polka();
        }
        this._server.add('GET', '/:id', function (req, res) {
            _this._handleVerification(req, res);
        });
        // tslint:disable-next-line:no-floating-promises
        this._server.add('POST', '/:id', function (req, res) {
            _this._handleNotification(req, res);
        });
        this._server.listen(this._config.port);
        try {
            for (var _b = tslib_1.__values(tslib_1.__spread(this._subscriptions.values())), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                // tslint:disable-next-line:no-floating-promises
                sub.start();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    WebHookListener.prototype.unlisten = function () {
        var e_2, _a;
        if (!this._server) {
            throw new Error('Trying to unlisten while not listening');
        }
        this._server.server.close();
        this._server = undefined;
        try {
            for (var _b = tslib_1.__values(tslib_1.__spread(this._subscriptions.values())), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                // tslint:disable-next-line:no-floating-promises
                sub.stop();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    WebHookListener.prototype.buildHookUrl = function (id) {
        var protocol = this._config.reverseProxy.ssl ? 'https' : 'http';
        var hostName = this._config.hostName;
        if (this._config.reverseProxy.port !== (this._config.reverseProxy.ssl ? 443 : 80)) {
            hostName += ":" + this._config.reverseProxy.port;
        }
        // trim slashes on both ends
        var pathPrefix = this._config.reverseProxy.pathPrefix.replace(/^\/|\/$/, '');
        return protocol + "://" + hostName + (pathPrefix ? '/' : '') + pathPrefix + "/" + id;
    };
    WebHookListener.prototype.subscribeToUserChanges = function (user, handler, withEmail, validityInSeconds) {
        if (withEmail === void 0) { withEmail = false; }
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = twitch_1.extractUserId(user);
                        subscription = new UserChangeSubscription_1.default(userId, handler, withEmail, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToFollowsToUser = function (user, handler, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = twitch_1.extractUserId(user);
                        subscription = new FollowsToUserSubscription_1.default(userId, handler, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToFollowsFromUser = function (user, handler, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = twitch_1.extractUserId(user);
                        subscription = new FollowsFromUserSubscription_1.default(userId, handler, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToStreamChanges = function (user, handler, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = twitch_1.extractUserId(user);
                        subscription = new StreamChangeSubscription_1.default(userId, handler, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToSubscriptionEvents = function (user, handler, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = twitch_1.extractUserId(user);
                        subscription = new SubscriptionEventSubscription_1.default(userId, handler, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToBanEvents = function (broadcaster, handler, user, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        broadcasterId = twitch_1.extractUserId(broadcaster);
                        userId = user ? twitch_1.extractUserId(user) : undefined;
                        subscription = new BanEventSubscription_1.default(broadcasterId, handler, this, userId, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToModeratorEvents = function (broadcaster, handler, user, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, userId, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        broadcasterId = twitch_1.extractUserId(broadcaster);
                        userId = user ? twitch_1.extractUserId(user) : undefined;
                        subscription = new ModeratorEventSubscription_1.default(broadcasterId, handler, this, userId, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    WebHookListener.prototype.subscribeToExtensionTransactions = function (extensionId, handler, validityInSeconds) {
        if (validityInSeconds === void 0) { validityInSeconds = this._config.hookValidity; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subscription = new ExtensionTransactionSubscription_1.default(extensionId, handler, this, validityInSeconds);
                        return [4 /*yield*/, subscription.start()];
                    case 1:
                        _a.sent();
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    /** @private */
    WebHookListener.prototype._changeIdOfSubscription = function (oldId, newId) {
        var sub = this._subscriptions.get(oldId);
        if (sub) {
            this._subscriptions.delete(oldId);
            this._subscriptions.set(newId, sub);
        }
    };
    /** @private */
    WebHookListener.prototype._dropSubscription = function (id) {
        this._subscriptions.delete(id);
    };
    WebHookListener.prototype._handleVerification = function (req, res) {
        var subscription = this._subscriptions.get(req.params.id);
        if (subscription) {
            if (req.query['hub.mode'] === 'subscribe') {
                subscription._verify();
                res.writeHead(202);
                res.end(req.query['hub.challenge']);
            }
            else {
                this._subscriptions.delete(req.params.id);
                res.writeHead(200);
                res.end();
            }
        }
        else {
            res.writeHead(410);
            res.end();
        }
    };
    WebHookListener.prototype._handleNotification = function (req, res) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var body, subscription;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, getRawBody(req, true)];
                    case 1:
                        body = _a.sent();
                        subscription = this._subscriptions.get(req.params.id);
                        if (subscription) {
                            res.writeHead(202);
                            res.end();
                            subscription._handleData(body, req.headers['x-hub-signature']);
                        }
                        else {
                            res.writeHead(410);
                            res.end();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return WebHookListener;
}());
exports.default = WebHookListener;
//# sourceMappingURL=WebHookListener.js.map