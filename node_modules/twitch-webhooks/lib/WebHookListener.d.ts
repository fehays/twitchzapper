import TwitchClient, { HelixBanEvent, HelixExtensionTransaction, HelixFollow, HelixModeratorEvent, HelixStream, HelixSubscriptionEvent, HelixUser, UserIdResolvable } from 'twitch';
import BanEventSubscription from './Subscriptions/BanEventSubscription';
import ExtensionTransactionSubscription from './Subscriptions/ExtensionTransactionSubscription';
import FollowsFromUserSubscription from './Subscriptions/FollowsFromUserSubscription';
import FollowsToUserSubscription from './Subscriptions/FollowsToUserSubscription';
import ModeratorEventSubscription from './Subscriptions/ModeratorEventSubscription';
import StreamChangeSubscription from './Subscriptions/StreamChangeSubscription';
import SubscriptionEventSubscription from './Subscriptions/SubscriptionEventSubscription';
import UserChangeSubscription from './Subscriptions/UserChangeSubscription';
interface WebHookListenerCertificateConfig {
    key: string;
    cert: string;
}
interface WebHookListenerReverseProxyConfig {
    port?: number;
    ssl?: boolean;
    pathPrefix?: string;
}
interface WebHookListenerConfig {
    hostName?: string;
    port?: number;
    ssl?: WebHookListenerCertificateConfig;
    reverseProxy?: WebHookListenerReverseProxyConfig;
    hookValidity?: number;
}
export default class WebHookListener {
    private readonly _config;
    /** @private */ readonly _twitchClient: TwitchClient;
    private _server?;
    private readonly _subscriptions;
    static create(client: TwitchClient, config?: WebHookListenerConfig): Promise<WebHookListener>;
    private constructor();
    listen(): void;
    unlisten(): void;
    buildHookUrl(id: string): string;
    subscribeToUserChanges(user: UserIdResolvable, handler: (user: HelixUser) => void, withEmail?: boolean, validityInSeconds?: number | undefined): Promise<UserChangeSubscription>;
    subscribeToFollowsToUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsToUserSubscription>;
    subscribeToFollowsFromUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsFromUserSubscription>;
    subscribeToStreamChanges(user: UserIdResolvable, handler: (stream?: HelixStream) => void, validityInSeconds?: number | undefined): Promise<StreamChangeSubscription>;
    subscribeToSubscriptionEvents(user: UserIdResolvable, handler: (subscriptionEvent: HelixSubscriptionEvent) => void, validityInSeconds?: number | undefined): Promise<SubscriptionEventSubscription>;
    subscribeToBanEvents(broadcaster: UserIdResolvable, handler: (banEvent: HelixBanEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<BanEventSubscription>;
    subscribeToModeratorEvents(broadcaster: UserIdResolvable, handler: (modEvent: HelixModeratorEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<ModeratorEventSubscription>;
    subscribeToExtensionTransactions(extensionId: string, handler: (transaction: HelixExtensionTransaction) => void, validityInSeconds?: number | undefined): Promise<ExtensionTransactionSubscription>;
    /** @private */
    _changeIdOfSubscription(oldId: string, newId: string): void;
    /** @private */
    _dropSubscription(id: string): void;
    private _handleVerification;
    private _handleNotification;
}
export {};
